
- `<prefix>::...` or `<prefix>::lib::...` for the bismuth standard library (implemented in bismuth for correctness guarantees). Eg, `<prefix>::Lists`
- `<prefix>::core::...` - stuff that's in the runtime library that can be used in both the runtime as well as programs. For example, the channel type, being part of the runtime and needing to be accessed by programs would be `<prefix>::core::Channel` though, in practice, you'd never see the FQN (special edge case). This would be implemented in IR/C for efficiency and such. Similarly, there could be redundant functions to those in the standard library that could be implemented more efficiently in IR/C. And, while they *should* be correct, you don't technically have the same theoretical properties as the proven language
- `<prefix>::generated::...` for code generated by the compiler in order to do stuff, but not directly accessible to the runtime or the user. For example, the functions needed to perform deep copies would be mangaled into this namespace. Similarly, extensions/plugins could have code go in here eg. `<prefix>::generated::LTL` and `<prefix>::generated::bismuth-session-protocol`
- `<prefix>::runtime:...` would then be the runtime functions that the user should not have direct access to (eg, the functions used internally to handle operations on channel)

*Why `<prefix>` instead of the typical `std`? I'm not sure what prefix I want to use. Given we go to llvm, there is always the potential of linking against the c standard library/functions (as well as rust and anything llvm based). While this should br limited per bismuths goals, it seems wrong to throw out the possibility for interoperability. As such, I'm tempted to use a prefix like `bsl` for bismuth standard libraryâ€”leaving `std` free for any future wrappers around c w/o having to add in a second layer of mangaling